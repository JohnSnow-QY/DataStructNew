#### 回溯法（backtracking)也称试探法，

 将问题的候选解按某种顺序逐一枚举和检验。

当发现当前的候选解不可能是解时，就放弃它而选择下一个候选解。如果当前的候选解**除了不满足问题规模要求外，其他所有要求都已满足，则扩大当前候选解的规模继续试探。** 

如果当前的候选解满足了包括问题规模在内的所有要求，则这个候选解将成为问题的一个解。

在回溯法中，放弃当前候选解，寻找下一个候选解的过程叫做回溯。扩大当前候选解的规模并继续试探的过程叫做向前试探。

###### 方法：用回溯法求解问题时常常使用递归方法进行试探，或使用栈帮助向前试探和回溯。

问题提法如下：把一只老鼠从一个无顶盖的迷宫的入口赶进迷宫，迷宫总设置了很多墙壁。在迷宫的唯一出口处放置了一块奶酪。如果从迷宫的入口到出口，途中不出现行进方向错误，则得到一条最佳路线 。**使用递归方法可获得迷宫从入口到出口的最佳路线**

解决方案： 用一个二维数组 maze [m+2] [p+2] 来表示迷宫，当数组元素maze [i] [j] = 1 时，表示该位置时墙壁，不能通行；

当maze [i] [j] =0 时，表示该位置是通路。 1<= i <= m ,i<=j <= p。 数组的第0行，第m+1行，第0列和第p+1列是迷宫的围墙。

![image-20210113165216962](C:\Personal\dataStruct\DataStructNew\extendFiles\用二维数组表示的迷宫.png)





在求解迷宫问题的过程中，当沿一条路径一步步走向出口当发现进入死胡同走不通时，就回溯一部或多步，寻找其他可走的路径。这就是回溯。

具体实现细节——方向的判定：

​	老鼠在迷宫中任一时刻的位置可用数组下标i和列下标j表示。从maze [i] [j] 出发，可能的前进方向有8个，按顺时针方向为

N([i-1] [j]) ,NE([i-1] [j+1] ),E([i] [j+1] ),SE([i+1] [j+1]]),S([i+1] [j]) ,SW([i+1] [j-1]), W([i] [j-1]),NW([i-1] [j-1])。

 ![image-20210113170020227](C:\Personal\dataStruct\DataStructNew\extendFiles\可能的前进方向.png)



设位置为[i] [j]标记为 X，实际时一系列交通路口。 分表代表8个前进位置。如果某一个方向时0值，表示该方向有路可通，否则表示该方向已堵死。

为有效地选择下一个位置，可以从位置[i] [j]出发可能的前进方向预先定义在一个表内。参看表3.3.

```c++
class offsets{ 			//位置在直角坐标下的偏移
    int a,b ;			//a,b是 x,y方向的偏移量
    char* dir;			//dir 是方向
}；
    offsets move[8];	//各个方向的偏移量
```



![image-20210113170903284](C:\Personal\dataStruct\DataStructNew\extendFiles\前进方向表.png)





 例如，当前位置在[i] [j]时，若向西南（SW)方向走，下一相邻位置[g] [h]则为

```c++
    g = i + move[5].a ;	//对应 g = i+1
    h = j + move[5].b ; // h = j-1;
d = move[5].dir;
```

当在迷宫中向前试探时，可根据前进方向表,选择某一个方向向前试探。如果该前进方向走不通，则在前进路径上回退一步，再尝试其他的运行方向。

​	为了防止重走原路，另外设置一个标志矩阵mark[m+2] [p+2],它的所有元素都初始化为0。一旦行进到迷宫给的某一个位置[i] [j],则将mark[i] [j] 置为1。下次这个位置就不能走了。

